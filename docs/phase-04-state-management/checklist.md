# Phase 4: 自己チェックリスト

Phase 4の理解度を確認するためのチェックリストです。
各項目を確認し、自信を持って「はい」と答えられるか確認してください。

## 目次

- [学習領域の概要](#学習領域の概要)
- [Jotai の基本](#jotai-の基本)
  - [理解度チェック](#理解度チェック)
  - [確認質問](#確認質問)
- [派生 Atom](#派生-atom)
  - [理解度チェック](#理解度チェック-1)
  - [確認質問](#確認質問-1)
- [永続化（atomWithStorage）](#永続化atomwithstorage)
  - [理解度チェック](#理解度チェック-2)
  - [確認質問](#確認質問-2)
- [atomFamily](#atomfamily)
  - [理解度チェック](#理解度チェック-3)
  - [確認質問](#確認質問-3)
- [フックの使い分け](#フックの使い分け)
  - [理解度チェック](#理解度チェック-4)
  - [確認質問](#確認質問-4)
- [演習問題](#演習問題)
  - [実装チェック](#実装チェック)
  - [コードレビュー](#コードレビュー)
- [総合評価](#総合評価)
  - [達成度の目安](#達成度の目安)
  - [特に重要なポイント](#特に重要なポイント)
- [振り返りチェック](#振り返りチェック)
- [次のステップ](#次のステップ)

## 学習領域の概要

```mermaid
pie title Phase 4 学習領域の構成
    "Atom の基本" : 20
    "派生 Atom" : 20
    "永続化" : 15
    "atomFamily" : 20
    "フックの使い分け" : 15
    "演習問題" : 10
```

***

## Jotai の基本

### 理解度チェック

- [ ] Jotaiの特徴を3つ以上挙げられる
- [ ] Atomの概念を説明できる
- [ ] `atom()` 関数でAtomを作成できる
- [ ] `useAtom` フックの使い方を理解している
- [ ] Atomをコンポーネントの外で定義する理由を説明できる

### 確認質問

1. JotaiとReduxの違いは何ですか？

   **回答例**: Jotaiはボイラープレートが少なく、ActionやReducerを定義する必要がない。Atom単位で状態を管理し、必要なAtomだけを購読できる。

2. Atomをコンポーネントの外で定義する理由は？

   **回答例**: コンポーネント内で定義すると、レンダリングのたびに新しいAtomが作成されてしまい、状態が共有されないため。

***

## 派生 Atom

### 理解度チェック

- [ ] 派生Atomの概念を説明できる
- [ ] `get` 関数の使い方を理解している
- [ ] 読み取り専用の派生Atomを作成できる
- [ ] 書き込み可能な派生Atomを作成できる
- [ ] 派生Atomの依存関係の自動追跡を理解している

### 確認質問

1. 派生Atomはどのような場合に使いますか？

   **回答例**: 他のAtomの値から計算される値を管理したい場合。例えば、カートアイテムから合計金額を計算する場合。

2. `atom((get) => ...)` と `atom(null, (get, set, ...) => ...)` の違いは？

   **回答例**: 前者は読み取り専用の派生Atom、後者は書き込み専用のAction Atom。両方を組み合わせて読み書き可能な派生Atomも作成できる。

***

## 永続化（atomWithStorage）

### 理解度チェック

- [ ] `atomWithStorage` の使い方を理解している
- [ ] localStorageとsessionStorageの違いを説明できる
- [ ] SSRでのHydration Mismatch問題を理解している
- [ ] カスタムストレージの作成方法を知っている

### 確認質問

1. `atomWithStorage` はどこからインポートしますか？

   **回答例**: `jotai/utils`

2. SSRでHydration Mismatchが発生する原因と対策は？

   **回答例**: サーバー側ではlocalStorageにアクセスできないため、サーバーとクライアントで値が異なる。対策として、`"use client"` を使う、Suspenseでラップする、クライアントサイドでのみ表示するなど。

***

## atomFamily

### 理解度チェック

- [ ] atomFamilyの概念を説明できる
- [ ] パラメータ付きAtomを作成できる
- [ ] など価性関数の必要性を理解している
- [ ] Atomのキャッシュについて理解している

### 確認質問

1. atomFamilyはどのような場合に使いますか？

   **回答例**: 同じ構造のAtomを動的に複数作成したい場合。例えば、商品IDごとに個別の数量を管理する場合。

2. オブジェクトをパラメータにする場合、なぜなど価性関数が必要ですか？

   **回答例**: JavaScriptでは `{a: 1} !== {a: 1}` なので、毎回新しいAtomが作成されてしまう。など価性関数を使って、値が同じなら同じAtomを返すようにする。

***

## フックの使い分け

### 理解度チェック

- [ ] `useAtom` の使いどころを理解している
- [ ] `useAtomValue` の使いどころを理解している
- [ ] `useSetAtom` の使いどころを理解している
- [ ] 各フックのパフォーマンス特性を説明できる

### 確認質問

1. `useSetAtom` を使うメリットは何ですか？

   **回答例**: Atomの値が変わっても再レンダリングされないため、パフォーマンスが向上する。イベントハンドラーで状態を更新するだけのコンポーネントに適している。

2. 以下のコードの問題点は？

   ```typescript
   function Button(): JSX.Element {
     const [_, setCount] = useAtom(countAtom);
     return <button onClick={() => setCount((c) => c + 1)}>+</button>;
   }
   ```

   **回答例**: 値を使っていないのに `useAtom` を使っているため、`countAtom` が変わるたびに再レンダリングされる。`useSetAtom` を使うべき。

***

## 演習問題

### 実装チェック

- [ ] ショッピングカート機能が動作する
- [ ] お気に入り機能が動作する
- [ ] 最近見た商品機能が動作する
- [ ] すべての機能でリロードしてもデータが保持される

### コードレビュー

自分のコードを以下の観点で確認してください。

- [ ] Atomはコンポーネントの外で定義している
- [ ] 読み取りのみはuseAtomValue、書き込みのみはuseSetAtomを使用している
- [ ] 派生Atomを使って計算ロジックを分離している
- [ ] TypeScriptの型が正しく設定されている

***

## 総合評価

### 達成度の目安

| 達成率       | 評価                    |
| --------- | --------------------- |
| 90% 以上    | 素晴らしい！Phase 5 に進みましょう |
| 70% - 89% | 良好。不安な部分を復習してから進む     |
| 50% - 69% | 該当するドキュメントを再読してください   |
| 50% 未満    | 最初からもう一度取り組みましょう      |

### 特に重要なポイント

1. **Atom の作成場所**
   - コンポーネントの外で定義すること

2. **フックの選択**
   - 読み取りのみ → `useAtomValue`
   - 書き込みのみ → `useSetAtom`
   - 両方 → `useAtom`

3. **永続化**
   - `atomWithStorage` でlocalStorageに保存
   - SSR時の注意点を理解

4. **派生 Atom**
   - 計算ロジックをAtomに分離
   - 依存関係の自動追跡

***

## 振り返りチェック

以下の質問に答えられますか？

1. **Jotai を選んだ理由を説明できるか**

2. **カート機能の実装で、どのような Atom を作成したか**

3. **パフォーマンス最適化のために、どのような工夫をしたか**

4. **実装中に遭遇した問題と、その解決方法**

***

## 次のステップ

チェックリストを確認して理解度に自信が持てたら、[Phase 5: データ取得 + MSW モック](../phase-05-data-fetching/README.md) に進みましょう。

Phase 5では、Server Componentsでのデータ取得とMSWを使ったAPIモックを学びます。
Phase 4で学んだ状態管理と組み合わせることで、より実践的なアプリケーションを構築できるようになります。
